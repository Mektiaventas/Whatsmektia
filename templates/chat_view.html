<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Chat con {{ chat[2] or chat[1] }}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
    <style>
        /* Estilos para mensajes nuevos */
        @keyframes highlightMessage {
            0% {
                background-color: rgba(0, 123, 255, 0.2);
            }

            100% {
                background-color: transparent;
            }
        }

        .new-message {
            animation: highlightMessage 1.5s ease-out forwards;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <a href="{{ url_for('chats') }}">← Volver</a>
    </div>
    <div class="chatbox">
        <!-- Replace the existing <h2> and nearby IA button with this block -->
        <div class="chat-title">
            <div class="card-title-row" style="align-items:center; gap:8px;">
                <span class="alias-view">{{ chat[2] or chat[1] }}</span>

                <span class="alias-edit" style="display:none;">
                    <input type="text" value="{{ chat[2] or '' }}" data-num="{{ chat[1] }}" maxlength="100" style="width: 180px;">
                </span>

                <button type="button" class="edit-alias-btn" data-num="{{ chat[1] }}" title="Editar nombre" style="background:none;border:0;cursor:pointer;font-size:14px;margin-left:6px;">
                    ✏️
                </button>

                <span style="font-size: 12px; margin-left:8px;">({{ chat[1] }})</span>
            </div>
        </div>

        <button id="btn-toggle-ia" onclick="toggleIA()">IA: <span id="ia-status">{{ 'Activa' if chat[3] else 'Desactivada' }}</span></button>
        <button id="btn-toggle-ia" onclick="toggleIA()">IA: <span id="ia-status">{{ 'Activa' if chat[3] else 'Desactivada' }}</span></button>
        <form method="POST" action="{{ url_for('guardar_nota', telefono=chat[1]) }}">
            <textarea name="nota" placeholder="Añadir nota..." maxlength="600">{{ chat[4] }}</textarea>
            <button type="submit">Guardar Nota</button>
        </form>
        <div class="mensajes" id="mensajes-container" aria-live="polite" role="log">
            {% for msg in mensajes %}
            <div class="{{ 'msg-in' if msg[3]=='entrante' else 'msg-out' }}" data-msg-id="{{ msg[0] }}">{{ msg[2] }}</div>
            {% endfor %}
        </div>

        <!-- Añadir campo para enviar mensaje manual -->
        <div class="mensaje-manual">
            <form method="POST" action="/send-manual" class="form-mensaje" id="form-manual">
                <input type="hidden" name="numero" value="{{ chat[1] }}">
                <input type="text" name="texto" placeholder="Escribe un mensaje..." class="input-mensaje" autocomplete="off" required>
                <button type="submit" class="btn-enviar">Enviar</button>
            </form>
        </div>
    </div>

    <script>
        // Configuration
        let chatAutoRefresh = true;
        const refreshInterval = 800; // ms
        let lastMessageId = {{ mensajes[-1][0] if mensajes else 0 }};
        const telefono = "{{ chat[1] }}";

        // Notification sound setup
        // Add a file at: static/audio/notify.mp3 (recommended). If not present, uses WebAudio fallback.
        const notifSrc = "{{ url_for('static', filename='audio/notify.mp3') }}";
        const _audio = new Audio(notifSrc);
        _audio.preload = 'auto';
        let audioUnlocked = false;
        let audioContext = null;

        // Try to unlock audio on first user interaction
        function tryUnlockAudioOnce() {
            if (audioUnlocked) return;
            // Play/pause to unlock on gesture
            _audio.play().then(() => {
                _audio.pause();
                _audio.currentTime = 0;
                audioUnlocked = true;
                document.removeEventListener('click', tryUnlockAudioOnce);
                document.removeEventListener('keydown', tryUnlockAudioOnce);
            }).catch(() => {
                // if play fails, prepare WebAudio context on gesture
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const o = audioContext.createOscillator();
                    const g = audioContext.createGain();
                    o.frequency.value = 0; // silent probe
                    o.connect(g); g.connect(audioContext.destination);
                    o.start(0); o.stop(0);
                    audioUnlocked = true;
                    document.removeEventListener('click', tryUnlockAudioOnce);
                    document.removeEventListener('keydown', tryUnlockAudioOnce);
                } catch (e) {
                    // ignore
                }
            });
        }
        document.addEventListener('click', tryUnlockAudioOnce);
        document.addEventListener('keydown', tryUnlockAudioOnce);

        function playWebAudioBeep() {
            try {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const ctx = audioContext;
                const o = ctx.createOscillator();
                const g = ctx.createGain();
                o.type = 'sine';
                o.frequency.value = 1000;
                g.gain.value = 0.08;
                o.connect(g);
                g.connect(ctx.destination);
                o.start();
                setTimeout(() => { o.stop(); }, 140);
            } catch (e) {
                // silent fallback
                console.warn('WebAudio beep failed', e);
            }
        }

        function playNotificationSound() {
            // don't disturb if tab not visible
            if (document.hidden) return;
            // prefer audio file if unlocked
            if (audioUnlocked) {
                _audio.currentTime = 0;
                _audio.play().catch((e) => {
                    // fallback to WebAudio
                    playWebAudioBeep();
                });
            } else {
                // try direct play (may be blocked) then fallback
                _audio.currentTime = 0;
                _audio.play().then(() => {
                    _audio.pause(); _audio.currentTime = 0;
                }).catch(() => {
                    playWebAudioBeep();
                });
            }
        }

        // Toggle IA (best-effort UI update; server may redirect)
        function toggleIA() {
            const statusEl = document.getElementById('ia-status');
            const current = statusEl.textContent.trim().toLowerCase();
            const optimistic = current === 'activa' ? 'Desactivada' : 'Activa';
            fetch("/toggle_ai/" + telefono, { method: "POST", credentials: 'same-origin', cache: 'no-store' })
                .then(resp => {
                    if (resp.redirected) {
                        window.location.href = resp.url;
                        return;
                    }
                    return resp.json().catch(() => ({ ia_activa: null }));
                })
                .then(body => {
                    if (body && typeof body.ia_activa !== 'undefined') {
                        statusEl.textContent = body.ia_activa ? 'Activa' : 'Desactivada';
                    } else {
                        statusEl.textContent = optimistic;
                    }
                })
                .catch(err => {
                    console.warn('toggleIA error:', err);
                    statusEl.textContent = optimistic;
                });
        }

        // Append message without duplicating; play sound for incoming messages
        function appendMessageToDOM(container, normalized) {
            if (!normalized || !normalized.id) return;
            if (container.querySelector(`[data-msg-id="${normalized.id}"]`)) return;

            const node = document.createElement('div');
            node.className = (String(normalized.direction).toLowerCase() === 'entrante') ? 'msg-in msg-box' : 'msg-out msg-box';
            node.dataset.msgId = normalized.id;
            node.textContent = normalized.content || '';
            node.classList.add('new-message');
            container.appendChild(node);
            setTimeout(() => node.classList.remove('new-message'), 1800);

            // Play notification only for incoming messages (common variants)
            const incomingMarkers = ['entrante', 'in', 'incoming', 'entrada'];
            const dir = String(normalized.direction || '').toLowerCase();
            if (incomingMarkers.includes(dir)) {
                playNotificationSound();
            }
        }

        function isScrolledToBottom(el) { return el.scrollHeight - el.clientHeight <= el.scrollTop + 60; }
        function scrollToBottom(el) { el.scrollTop = el.scrollHeight; }

        // Robust fetch + normalization + logging
        async function actualizarMensajes(container) {
            if (!chatAutoRefresh) return;
            try {
                const url = `/chat/${encodeURIComponent(telefono)}/messages?after=${lastMessageId}`;
                const res = await fetch(url, { credentials: 'same-origin', cache: 'no-store' });
                if (!res.ok) return;
                const data = await res.json().catch(() => null);
                if (!data || !Array.isArray(data.messages)) return;
                const msgs = data.messages;
                if (msgs.length === 0) return;

                const wasAtBottom = isScrolledToBottom(container);
                for (const m of msgs) {
                    const normalized = {
                        id: Number(m.id ?? m[0] ?? m['id'] ?? 0),
                        content: (m.content ?? m['content'] ?? m.mensaje ?? m['mensaje'] ?? m.respuesta ?? m[2] ?? ''),
                        direction: (m.direction ?? m['direction'] ?? m.direccion ?? m['direccion'] ?? (m[3] ?? null))
                    };
                    if (!normalized.id) continue;
                    appendMessageToDOM(container, normalized);
                    lastMessageId = Math.max(lastMessageId, normalized.id);
                }
                if (wasAtBottom) scrollToBottom(container);
            } catch (err) {
                console.error('Error updating messages:', err);
            }
        }

        // Initialize lastMessageId from DOM rendered messages to avoid duplicates
        function initLastMessageFromDOM(container) {
            try {
                if (!container) return;
                const nodes = container.querySelectorAll('[data-msg-id]');
                let max = lastMessageId || 0;
                nodes.forEach(n => { const v = Number(n.dataset.msgId) || 0; if (v > max) max = v; });
                lastMessageId = max;
            } catch (e) {
                console.warn('initLastMessageFromDOM error:', e);
            }
        }

        // Edit alias helper (adapted from kanban to behave the same)
        function activarEdicionAlias(parent) {
            if (!parent) return;
            const view = parent.querySelector('.alias-view');
            const edit = parent.querySelector('.alias-edit');
            if (!view || !edit) return;
            const input = edit.querySelector('input[type=text]');
            if (!input) return;

            const original = (view.textContent || '').trim();
            if (!input.value || input.value.trim() === '') input.value = original;

            view.style.display = 'none';
            edit.style.display = 'inline-flex';
            input.focus();
            input.select();

            let submitted = false;

            function finishAndRestore(valueToShow) {
                edit.style.display = 'none';
                view.textContent = (typeof valueToShow !== 'undefined' && valueToShow !== null) ? valueToShow : input.dataset.num;
                view.style.display = '';
            }

            function terminar() {
                const nuevo = (input.value || '').trim();

                if (nuevo === '' || nuevo === original) {
                    finishAndRestore(original);
                    return;
                }

                submitted = true;
                fetch(`/contactos/${encodeURIComponent(input.dataset.num)}/alias`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({ alias: nuevo })
                }).then(res => {
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    return res;
                }).then(() => {
                    finishAndRestore(nuevo);
                }).catch(err => {
                    console.warn('Error guardando alias:', err);
                    finishAndRestore(original);
                }).finally(() => { submitted = false; });
            }

            // onblur: give a tick to avoid conflict with Enter key
            input.onblur = () => {
                setTimeout(() => {
                    if (!submitted) terminar();
                }, 0);
            };

            input.onkeydown = (ev) => {
                if (ev.key === 'Enter') { ev.preventDefault(); terminar(); }
                if (ev.key === 'Escape') { edit.style.display = 'none'; view.style.display = ''; }
            };
        }

        // Bind helpers for edit buttons (call immediately and on DOMContentLoaded to avoid timing issues)
        function bindEditAliasButtons() {
            try {
                document.querySelectorAll('.edit-alias-btn').forEach(btn => {
                    if (btn.dataset.boundAlias === '1') return;
                    btn.dataset.boundAlias = '1';
                    btn.addEventListener('click', function (e) {
                        e.preventDefault(); e.stopPropagation();
                        // Find the right parent (chat title row or card title row)
                        const parent = this.closest('.card-title-row') || this.closest('.chat-title') || this.closest('.chatbox') || document.body;
                        if (!parent) return;
                        activarEdicionAlias(parent);
                    });
                });
            } catch (err) {
                console.error('Error binding edit-alias-btn handlers:', err);
            }
        }

        // attempt binding now (covers case where DOMContentLoaded already fired)
        bindEditAliasButtons();

        // Bind handlers after DOM is ready as well
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('mensajes-container');
            initLastMessageFromDOM(container);

            bindEditAliasButtons();

            // Start incremental refresh loop that uses actualizarMensajes
            setInterval(() => {
                const mensajesContainer = document.getElementById('mensajes-container');
                actualizarMensajes(mensajesContainer);
            }, refreshInterval);
        });
    </script>
</body>
</html>